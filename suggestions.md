# Suggestions

Improvements, new features, and future directions surfaced by Claude during
development. The human decides what to pull into spec.md.

## Active

- [improvement] The lexer silently skips unrecognized characters (line 113: bare `i += 1` fallthrough) — `#z`, stray `#` without `t`/`f`, or non-ASCII garbage won't produce an error or a token, they just vanish. This masks typos in real programs. Consider returning `Err("unexpected character: ...")` from the catch-all branch. (surfaced after *Stories: E1.1*)
- [improvement] Value formatting is duplicated in three places: `repl.rs:format_value()` for REPL output, `builtins.rs:268-280` for `display`, and `{:?}` Debug fallback in error messages (`eval.rs:138`, `builtins.rs:280`). Implement `Display` for `Value` to centralize all user-facing formatting — the REPL, `display`, and error messages all need the same Lisp-readable representation. Without this, `(display '(1 2))` prints `List([Number(1.0), Number(2.0)])` (Debug) instead of `(1 2)`. (surfaced after **E1.10**, updated after **E1.16**)
- [improvement] `cons` onto a `Value::List` uses `Vec::insert(0, head)` which is O(n) — every `cons` onto a list copies the entire vector. This is invisible for small programs but will become a bottleneck in Phase 7 (E2.5 integration tests with `map`/`filter` building lists via recursive `cons`). Consider making `List` a linked structure (e.g. always use `Pair` chains with a `Nil` sentinel) or accept the cost and document it. The hybrid `List`/`Pair` representation also complicates every function that matches on both variants. (surfaced after **E1.15**)
- [direction] The lexer's string escape handling (`lexer.rs:71-74`) treats `\` followed by any character as that literal character — `\n` becomes `n`, `\t` becomes `t`. Real Lisps interpret these as newline and tab. With the REPL now live, `(display "hello\nworld")` outputs `hellonworld`. Add an escape table mapping `n`→newline, `t`→tab, `\\`→backslash, `\"`→quote before Epic 2 introduces more complex programs. (surfaced after **E1.15**, updated after **E1.16**)
- [improvement] Evaluating an empty list `()` returns `Err("not implemented")` (`eval.rs:13`) — this is a leftover stub. It should say `"cannot evaluate empty list"` or similar. Before Epic 2 adds `let`/`let*`/`letrec`, this is the only error a user sees when they accidentally type `()`, and "not implemented" is misleading. (surfaced after **E1.16**)
- [direction] No tail call optimization — recursive Strawman programs overflow the Rust call stack. E2.5 integration tests include `(factorial 10)` and `(fibonacci 10)` which are shallow enough to work, but real programs using `map`/`filter` on longer lists will crash. Consider a trampoline in `straw_eval` for tail-position calls before or during Epic 3 (continuations). (surfaced after **E1.16**)

## Deprecated

- [~~direction~~] Add a `Quote` token to the lexer before building the parser — done: `Token::Quote` variant exists and the parser desugars `'x` into `(quote x)` correctly. (deprecated after *Stories: E1.2*)
- [~~improvement~~] `Token` derives `PartialEq` but not `Clone` — turned out the parser only borrows tokens via `&[Token]` and never needs to clone them. The slice+index approach sidestepped the issue entirely. `Clone` can still be added later if needed but is no longer blocking. (deprecated after *Stories: E1.2*)
- [~~direction~~] `Expr` needs `Clone` (and likely `Expr` ≠ `Value`) before E1.4 — resolved: `Expr` derives `Clone`, and `Value` is a separate enum in `env.rs` with `Closure`, `Builtin`, and `Void` variants. The syntax/runtime split is clean. (deprecated after **E1.10 — Function application**)
- [~~direction~~] Environment ownership model requires `Rc<RefCell<Env>>` — resolved with a better design: `Rc<Env>` with `RefCell` only on the inner `HashMap<String, Value>`, not the whole `Env`. This is more granular and avoids broad interior mutability. Closures capture `Rc<Env>`, `set!` mutates through `RefCell<HashMap>`. (deprecated after **E1.10 — Function application**)
- [~~direction~~] `Value::List(Vec<Value>)` cannot represent dotted pairs — resolved: `Value::Pair(Box<Value>, Box<Value>)` was added alongside `Value::List`. `cons` produces `Pair` when the tail is not a list, and `car`/`cdr`/`null?`/`pair?` all handle both variants. (deprecated after **E1.15 — Type predicates & I/O**)
- [~~direction~~] `and`/`or` must be special forms in the evaluator, not builtins — done: both are match arms in `straw_eval` (`eval.rs:79-103`) with proper short-circuit semantics. They are not in `default_env`. (deprecated after **E1.15 — Type predicates & I/O**)

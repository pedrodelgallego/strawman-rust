# Suggestions

Improvements, new features, and future directions surfaced by Claude during
development. The human decides what to pull into spec.md.

## Active

- [improvement] The lexer silently skips unrecognized characters (line 113: bare `i += 1` fallthrough) — `#z`, stray `#` without `t`/`f`, or non-ASCII garbage won't produce an error or a token, they just vanish. This masks typos in real programs. Consider returning `Err("unexpected character: ...")` from the catch-all branch. (surfaced after *Stories: E1.1*)
- [improvement] Value formatting is duplicated in three places: `repl.rs:format_value()` for REPL output, `builtins.rs:268-280` for `display`, and `{:?}` Debug fallback in error messages (`eval.rs:138`, `builtins.rs:280`). Implement `Display` for `Value` to centralize all user-facing formatting — the REPL, `display`, and error messages all need the same Lisp-readable representation. Without this, `(display '(1 2))` prints `List([Number(1.0), Number(2.0)])` (Debug) instead of `(1 2)`. (surfaced after **E1.10**, updated after **E1.16**)
- [improvement] `cons` onto a `Value::List` uses `Vec::insert(0, head)` which is O(n) — every `cons` onto a list copies the entire vector. This is invisible for small programs but will become a bottleneck in Phase 7 (E2.5 integration tests with `map`/`filter` building lists via recursive `cons`). Consider making `List` a linked structure (e.g. always use `Pair` chains with a `Nil` sentinel) or accept the cost and document it. The hybrid `List`/`Pair` representation also complicates every function that matches on both variants. (surfaced after **E1.15**)
- [direction] The lexer's string escape handling (`lexer.rs:71-74`) treats `\` followed by any character as that literal character — `\n` becomes `n`, `\t` becomes `t`. Real Lisps interpret these as newline and tab. With the REPL now live, `(display "hello\nworld")` outputs `hellonworld`. Add an escape table mapping `n`→newline, `t`→tab, `\\`→backslash, `\"`→quote before Epic 2 introduces more complex programs. (surfaced after **E1.15**, updated after **E1.16**)
- [improvement] Evaluating an empty list `()` returns `Err("not implemented")` (`eval.rs:13`) — this is a leftover stub. It should say `"cannot evaluate empty list"` or similar. Before Epic 2 adds `let`/`let*`/`letrec`, this is the only error a user sees when they accidentally type `()`, and "not implemented" is misleading. (surfaced after **E1.16**)
- [direction] No tail call optimization — recursive Strawman programs overflow the Rust call stack. E2.5 integration tests include `(factorial 10)` and `(fibonacci 10)` which are shallow enough to work, but real programs using `map`/`filter` on longer lists will crash. Consider a trampoline in `straw_eval` for tail-position calls before or during Epic 3 (continuations). (surfaced after **E1.16**)
- [direction] The error type is a flat `String` everywhere (`Result<Value, String>`) — the CPS evaluator now uses three sentinel strings (`\0cont-escape\0`, `\0throw-escape\0`, `\0block-escape\0`) plus five thread-local `RefCell<Option<...>>` variables to simulate non-local jumps. This works but is brittle: stale thread-local state can leak if cleanup is missed, and string-matching on sentinels is fragile. Replace with `enum EvalSignal { Error(String), ContinuationEscape(Value), ThrowEscape(String, Value), BlockEscape(String, Value) }` to make control flow type-safe and eliminate the thread-locals. Best done before E4 to avoid further accumulation of sentinel/thread-local machinery. (surfaced after **E2.5 — Integration**, updated after **E3.5**)
- [improvement] `eval.rs` has grown to 612 lines with 19 special forms in a single `match` arm — `let`/`let*`/`letrec` each have ~40 lines of nearly identical binding-parse-eval-body logic, and the identity continuation `let id: Cont = Rc::new(|v| Ok(v))` is repeated ~20 times. Extract a shared `eval_body_in_env` helper and a reusable identity continuation to reduce duplication. E6 (fast interpretation) will restructure the evaluator anyway, so this is best done as a preparatory cleanup during E5. (surfaced after **E2.5 — Integration**, updated after **E4.4**)
- [direction] `procedure?` returns `#f` for continuations (`Value::Continuation`) — in standard Scheme, continuations are procedures. Since `call/cc` is now implemented and continuations are callable, `procedure?` should match on `Value::Continuation` too. This will matter for E4+ programs that pass continuations to higher-order functions. Note: the denotational semantics (§5.5) explicitly defines `procedure?` as `Closure + Builtin` only — if this is changed, semantics.md must be updated too. (surfaced after **E3.5**, updated after **E5.2**)
- [direction] `set-car!`/`set-cdr!` uses copy-on-write, not true in-place mutation — the implementation (`eval.rs:414-447`) creates a new value and updates the variable binding, so aliased pairs don't share mutations: `(define p (cons 1 2)) (define q p) (set-car! p 99) (car q)` returns `1`, not `99`. This is now formally specified in semantics.md (§4.12) as `update(x, Pair(v, d), env)`, making it a deliberate design choice. However, if E8 (eval/reflection) or E10 (objects) need aliased mutation, pairs will need `Rc<RefCell<(Value, Value)>>` and the semantics will need revision. (surfaced after **E4.4**, updated after **E5.2**)
- [improvement] `eq?` doesn't check identity for `Pair` or `Vector` values — `eq?` (`builtins.rs:149-163`) uses `Rc::ptr_eq` for `List` but falls through to `false` for all `Pair` comparisons (which use `Box`, not `Rc`) and doesn't use `Rc::ptr_eq` for `Vector` despite vectors using `Rc<RefCell<...>>`. Since `vector-set!` provides true in-place mutation, two bindings to the same vector should be `eq?`-identical. Add an `(Value::Vector(a), Value::Vector(b)) => Rc::ptr_eq(a, b)` arm. (surfaced after **E4.4**)
- [direction] The denotational semantics document (`docs/semantics.md:489`) defines `procedure?` as `Bool(v in Closure + Builtin)`, deliberately excluding continuations — but standard Scheme (R5RS §6.1) specifies that continuations created by `call/cc` are procedures. This means the formal semantics and the implementation agree with each other but diverge from Scheme. Before E6 adds lexical addressing, decide whether `Cont` belongs in the `procedure?` domain and update both semantics.md and the implementation together. This also affects the existing active suggestion about `procedure?`. (surfaced after *Stories: E5.1, E5.2*)
- [direction] The copy-on-write semantics for `set-car!`/`set-cdr!` are now formally documented in semantics.md (§4.12: `update(x, Pair(v, d), env)`) — this makes the binding-update approach a deliberate design choice rather than a known shortcut. However, E6's pretreatment pass will need to know which forms mutate state vs. rebind variables, and copy-on-write means `set-car!` is semantically closer to `set!` than to true mutation. If E6 introduces an optimization pass that distinguishes pure from impure forms, the conflation of mutation and rebinding will complicate the analysis. Worth revisiting if E6's pretreatment needs a purity analysis. (surfaced after *Stories: E5.1, E5.2*)
- [improvement] `test_semantics.rs` uses two helper functions (`eval` and `eval_multi`) that duplicate the parse-eval pattern found in every other test file (`test_eval.rs`, `test_builtins.rs`, etc.). With 7 test files now sharing this exact pattern, a shared test utility module (`tests/common/mod.rs`) would reduce boilerplate and ensure consistent error handling across test suites. This becomes more valuable as E6+ adds more test files. (surfaced after *Stories: E5.1, E5.2*)

## Deprecated

- [~~direction~~] `Value::Builtin` uses bare `fn` pointers which cannot capture state, blocking continuations — resolved differently: `Value::Continuation(Rc<dyn Fn(...)>)` was added as a separate variant in E3 rather than unifying the calling convention. Builtins remain `fn` pointers, which is sufficient for now. The `fn` vs `Rc<dyn Fn>` split may resurface for `apply`/`eval` in E8, but the original motivation (blocking E3) is moot. (deprecated after **E3.5**)
- [~~direction~~] Add a `Quote` token to the lexer before building the parser — done: `Token::Quote` variant exists and the parser desugars `'x` into `(quote x)` correctly. (deprecated after *Stories: E1.2*)
- [~~improvement~~] `Token` derives `PartialEq` but not `Clone` — turned out the parser only borrows tokens via `&[Token]` and never needs to clone them. The slice+index approach sidestepped the issue entirely. `Clone` can still be added later if needed but is no longer blocking. (deprecated after *Stories: E1.2*)
- [~~direction~~] `Expr` needs `Clone` (and likely `Expr` ≠ `Value`) before E1.4 — resolved: `Expr` derives `Clone`, and `Value` is a separate enum in `env.rs` with `Closure`, `Builtin`, and `Void` variants. The syntax/runtime split is clean. (deprecated after **E1.10 — Function application**)
- [~~direction~~] Environment ownership model requires `Rc<RefCell<Env>>` — resolved with a better design: `Rc<Env>` with `RefCell` only on the inner `HashMap<String, Value>`, not the whole `Env`. This is more granular and avoids broad interior mutability. Closures capture `Rc<Env>`, `set!` mutates through `RefCell<HashMap>`. (deprecated after **E1.10 — Function application**)
- [~~direction~~] `Value::List(Vec<Value>)` cannot represent dotted pairs — resolved: `Value::Pair(Box<Value>, Box<Value>)` was added alongside `Value::List`. `cons` produces `Pair` when the tail is not a list, and `car`/`cdr`/`null?`/`pair?` all handle both variants. (deprecated after **E1.15 — Type predicates & I/O**)
- [~~direction~~] `and`/`or` must be special forms in the evaluator, not builtins — done: both are match arms in `straw_eval` (`eval.rs:79-103`) with proper short-circuit semantics. They are not in `default_env`. (deprecated after **E1.15 — Type predicates & I/O**)
- [~~direction~~] E4.2 will require mutable pairs via `Rc<RefCell<...>>` — resolved differently: E4.2 was implemented with copy-on-write semantics (create a new pair, update the variable binding) rather than true in-place mutation. This avoids the pervasive `Rc<RefCell>` refactor at the cost of not supporting aliased mutation. The trade-off was accepted; a new suggestion tracks the remaining semantic gap. (deprecated after **E4.4**)
- [~~direction~~] E4.3 `eq?` is fundamentally incompatible with clone-on-lookup — resolved pragmatically: `eq?` uses value equality for primitives (`Number`, `Boolean`, `Symbol`, `StringLit`) and `Rc::ptr_eq` for `List`. The clone-on-lookup issue is real but only matters for compound types, and the current tests pass. The remaining gap (no `eq?` for vectors/pairs) is tracked in a new, more specific suggestion. (deprecated after **E4.4**)
